

# This file was *autogenerated* from the file bit_btp.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_6 = Integer(6); _sage_const_351p0 = RealNumber('351.0'); _sage_const_1p0 = RealNumber('1.0'); _sage_const_0p0 = RealNumber('0.0')# 导入必需的 SageMath 模块
from sage.all import *

# 定义函数 f(x) = (1 - cos(2πx))/2
def f(x):
    return (_sage_const_1  - cos( pi * x)) / _sage_const_2 

def AND(x, y):
    x = (x+y)/_sage_const_3 
    return ( _sage_const_1  - _sage_const_2  * sin( _sage_const_2 *pi*x + pi/_sage_const_6  ) ) / _sage_const_3 
def NAND(x, y):
    x = (x+y)/_sage_const_3 
    return ( _sage_const_2  * ( _sage_const_1  + sin( _sage_const_2 *pi*x + pi/_sage_const_6  ) ) ) / _sage_const_3 
def OR(x, y):
    x = (x+y)/_sage_const_3 
    return _sage_const_2 *(_sage_const_1  - cos(_sage_const_2 *pi*x)) / _sage_const_3 
def XOR(x,y):
    x = (x+y)/_sage_const_3 
    return ( _sage_const_1  + _sage_const_2 *sin(_sage_const_2 *pi*x - pi/_sage_const_6  )) / _sage_const_3 
def NOR(x,y):
    x = (x+y)/_sage_const_3 
    return (_sage_const_1  + _sage_const_2  * cos(_sage_const_2 *pi*x)) / _sage_const_3 
def XNOR(x,y):
    x = (x+y)/_sage_const_3 
    return  _sage_const_2 * (_sage_const_1  - sin(_sage_const_2 *pi*x - pi/_sage_const_6  ) ) / _sage_const_3 

# 指定计算的点
x_value = _sage_const_351p0 
# x_value = x_value/2
# 计算 f(x_value)
result = f(x_value).n()  # 或者使用 .numerical_approx() 同样效果

a = _sage_const_1p0 
b = _sage_const_0p0 
y = AND(a, b).n()
# 输出结果
print(f"AND: f({a},{b}) = {y}")
y = NAND(a, b).n()
# 输出结果
print(f"NAND: f({a},{b}) = {y}")

y = OR(a, b).n()
# 输出结果
print(f"OR: f({a},{b}) = {y}")

y = XOR(a, b).n()
# 输出结果
print(f"XOR: f({a},{b}) = {y}")

y = NOR(a, b).n()
# 输出结果
print(f"NOR: f({a},{b}) = {y}")

y = XNOR(a, b).n()
# 输出结果
print(f"XNOR: f({a},{b}) = {y}")

# 输出结果
print(f"f({x_value}) = {result}")

